;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(let [] 10)" "(re-find #\"([a-zA-Z]+) := (.+)\" \"x := 10\")" "(re-seq #\"([a-zA-Z]+) := (.+)\" \"x := 10\")" "(symbol \"x\")" "(symbol \"foo\")" "(re-seq #\"(.*)-(.*)\" \"a-b\")" "'x1" "'1x" "(let [[foo bar baz] '(1)] [foo bar baz])" "(coll? \"foo\")" "(coll? #{1 2 3})" "(coll? {1 2 3 4})" "(coll? '(1 2 3))" "(coll? [1 2 3])" "(apply vector 1 2 [3 4])" "(apply vector 1 2 [3])" "(vector 1 2 [3])" "(vector? [1])" "(list? [1])" "(count '(1))" "(list* '(1 2) 3)" "(let [:: 1] ::)" "('+ 1)" "+ 1 2" "(apply '+ 1 2)" "('+ 1 2)" "(doc +)" "(seqable? [1 2 3])" "(< 1 2 1)" "(< 2 1 3)" "(< 1 2 3 4)" "(< 1 2 3)" "(< 1 2)" "(dotimes [i 5 j 6])" "(vector [:a :b :c])" "((fn [[a b] :as foo] foo) [1 2])" "(disj #{[1 2] [3 4]} [1 2])" "(flatten (seq #{[1 2] [3 4]}))" "(flatten #{[1 2] [3 4]})" "(sort \"fooC\")" "(compare \\C \\a)" "(compare \\c
               \\a)" "(compare \\b \\a)" "(compare \\a \\b)" "(sort \"foosa\")" "(sort \"foo\")" "(sort [\\b \\a \\c])" "(sort [\\a \\b \\c])" "(int \\a)" "(int \\b)" "(> \\b \\a)" "\\b" "(> /b /a)" "(time (dotimes [i 1000] (apply concat [[[1]] [[2 3]]])))" "(time (dotimes [i 1000] (mapcat identity [[[1]] [[2 3]]])))" "(time (dotimes [i 1000] (apply concat [[[1]] [[2 3]]])))" "(time (dotimes [i 1000] (mapcat identity [[[1]] [[2 3]]])))" "(time (dotimes 1000 (mapcat identity [[[1]] [[2 3]]])))" "(apply concat [[[1]] [[2 3]]])" "(concat [[[1]] [[2 3]]])" "(mapcat identity [[[1]] [[2 3]]])" "(flatten [[[1]] [[2 3]]])" "(flatten nil)" "(flatten (seq {:foo {:bar 2}}))" "(flatten (seq {:foo 1 :bar 2}))" "(flatten {:foo 1 :bar 2})" "(concat {:foo 1} {:bar 2})" "(concat [1] [2])" "(vals {:foo 1 :bar 2})" "(values {:foo 1 :bar 2})" "(keys [[:foo 1] [:bar 2]])" "(keys {:foo 1 :bar 2})" "(rest '(3))" "(rest '(2 3))" "(rest '(1 2 3))" "'(1 2 3)" "(rest nil)" "(next nil)" "(rest nil)" "(next [])" "(rest [])" "(next [1 2 3])" "(rest [1 2 3])" "(next [])" "(rest [])" "(next [1 2 3])" "(realized? (rest [1 2 3]))" "(rest [1 2 3])" "(first [1 2 3])" "(rest '(1 2 3))" "(first '(1 2 3))" "(rest \"foo\")" "(first \"foo\")" "(first {:foo 42})" "(first #{1 2 3})" "(hash-set 1 2 3)" "(first (hash-set 1 2 3))" "(doc set)" "(first (set 1 2 3))" "(first [1 2 3])" "(first (list 1 2 3))" "(first \"foo\")" "(rest {:foo 42 :bar 84})" "(first {:foo 42})" "(println 'foo)" "(str 'foo)" "(let [foo 1] (println \"foo\" foo))" "log" "1 2 3" "'foo 'bar" "(->> '(3 4) (cons 2) (cons 1))" "(cons 1 (cons 2 '(3 4)))" "(conj '(3 4) 2 1)" "(conj [3 4] 2 1)" "(list* 1 2 [3 4])" "(doc realized?)" "(+ 1 2)" "default-flags" "open" "default-flags" "(+ 1 2)" "(nil? ())" "(nil? nil)" "(empty? nil)" "(empty? ())" "(= nil ())" "(merge {:foo :bar} nil)" "(merge {:foo :bar} ())" "(merge {:foo :bar} false)" "(merge {:foo :bar} nil)" "(merge {:style {:foo :bar}} {:bar :baz})" "(apply println \"foo\" '(\"bar\" \"baz\"))" "(doc apply)" "(conj [:foo] :bar)" "(assoc (sorted-map :c 2 :b 1) :a 3)" "(sorted-map :b 1 :a 2)" "(sorted-map :a 1 :b 2)" "[:foo (when false :bar)]" "(doc ->js)" "(map identity {0 {:foo false}})" "(map identity {0 {:foo :bar}})" "(map identity {:foo {:bar :baz}})" "(into {} '([:foo :bar]))" "(into {} [:foo :bar])" "tasks" "(into [:foo] [:bar :baz])" "(doc push)" "(doc complement)" "(doc defrecord)" "*ns*" "(in-ns 'user)" "*ns*" "(in-ns 'foo)" "*ns*" "(doc assert)" "(doc comment)" "(doc require)" "(doc locking)" "(doc pos?)" "(doc zipmap)" "(let [x 0]
        (Math/max 0 (dec x)))" "(let [x 3]
        (Math/max 0 (dec x)))" "(let [x 2]
        (Math/max 0 (dec x)))" "(let [x 2]
        (Math/min 0 (dec x)))" "(doc into)" "(type 'foo)" "::foo" ":foo" "(type :::foo)" "(type ::foo)" "(type :foo)" "{:foo :bar :baz :qun}" "(count {:foo 1, :bar 2, :baz 3})" "(count {:foo :bar :baz :qun})" "(assoc '(1 2) 0 100)" "(assoc [1 2] 0 100)" "(conj [:foo] 'Clojure 'ClojureScript)" "(let [m {{:foo \"bar\"} \"baz\"}]
        (get m {:foo \"bar\"}))" "(get {1 \"bar\"} 1)" "{1 \"bar\"}" "(identity :foo)" "(= {:foo \"bar\"} {:foo \"bar\"})" "(= {:foo 1} {:foo 1})" "`foo" "'foo" "`[:foo]" "'[:foo]" "`[1 2 ~@[3 4]]" "`[1 2 @~[3 4]]" "(doc subvec)" "(doc Math/min)" "(doc subvec)" "(doc fn?)" "(fn? hellos)" "'?foo" "(doc map-indexed)" "(def foo [\"Ant\" \"Antelope\" \"Bird\" \"Cat\" \"Dog\" \"Lion\" \"Mouse\" \"Monkey\" \"Snake\" \"Zebra\"])" "(get {:foo :bar} :baz)" "(find {:foo :bar} :baz)" "(get {:foo :bar} :foo)" "(find {:foo :bar} :foo)" "(doc find)" "(update (range 3) 0 identity)" "(update-in (vec '(1 2 3)) [0] identity)" "(update-in '(1 2 3) [0] identity)" "(mod 4 3)" "(mod 3 3)" "(mod 2 3)" "(mod 1 3)" "(mod 0 3)" "(mod 3 3)" "(mod 2 3)" "(mod 1 3)" "(mod 2 2)" "(mod 1 2)" "(mod 6 2)" "(mod 5 2)" "(last (last []))" "(split-with (partial = 1) [1 1 2 1 1])" "(into [] '(1 2 3))" "(into [1 2 3] [1 2])" "(Character/isUpperCase \\F)" "(is-upper-case? \"F\")" "(is-upper-case? \\F)" "(concat '(1 2) '(3))" "clojure.contrib.core/seqable?" "(seq 1)" "(seqable? {:foo :bar})" "(seq? {:foo :bar})" "(reverse \"foo\")" "((partial reduce second) [0 1 2 3])" "((partial reduce (fn [_ val] val)) [0 1 2 3])" "(reduce #(%2) [0 1 2 3])" "(reduce (fn [a b] b) [0 1 2 3])" "(#(str \"Hello, \" %) \"foo\")" "(= (rest [10 20 30 40]) [20 30 40])" "(rest [10 20 30 40])" "(into {} '(:a 1))" "(into {} '((:a 1)))" "(into {} [[:a 1]])" "(into {} [:a 1])" "(into {} {:a 1})" "(cons [:a 1] {})" "(cons {} [:a 1])" "(conj {} '((:a 1)))" "(conj {} '(:a 1))" "(conj {} [:a 1])" "(conj {} {:a 1})" "(= [1 2 3] '(1 2 3))" "(doc list)" "(not nil)" "(== 1.5 1)" "(== 1.0 1)" "(= 1.0 1)" "(doc =)" "(doc ==)" "(int 2.5)" "(read-string \"(1,2,3,,,)\")" "(str \"(\" \"1,2,3\" \")\")" "(distinct [1 1 2 3 4])" "(distinct '(1 2 3 3))" "clojure.math.numeric-tower" "math.numeric-tower" "(int? 3.0)" "(Math/sqrt 4)" "(clojure.math/sqrt 4)" "(clojure.Math/sqrt 4)" "(Math.sqrt 4)" "(read-string \"(1,2,3)\")" "(read-string \"1,2,3\")" "(read-string \"(+ 1 2)\")" "(read)" "(read \"(+ 1 2)\")" "(== (int 2.5) 2.5)" "(== (int 3.0) 3.0)" "(== 3 3.0)" "(= 3 3.0)" "(int 2.5)" "(int 3.0)" "(integer? 3.0)" "(frequencies (vec \"foo\"))" "(frequencies \"foo\")" "(count \"foo\")" "(dissoc (vec \"foo\") 1)" "(= (frequencies (vec \"foo\")) (frequencies (vec \"ofo\")))" "(doc remove)" "(remove (vec \"foo\") 1)" "(dissoc (vec \"foo\") 1)" "(vec \"foo\")" "(set \"foo\")" "(count \"foo\")" "(my.. 1 11)" "(def my.. range)" "(.. 1 11)" "(def .. range)" ".." "." "(split-with #(>= % 1) [1 2 3 1 2 3 4])" "(split-with #(>= % 1) [2 3 1 2 3 4])" "(split-with #(> % 1) [2 3 1 2 3 4])" "(split-with #(= % 1) [2 3 1 2 3 4])" "(split-with #(= % 1) [1 2 3 1 2 3 4])" "(doc if-some)" "(rest ())" "(rest [])" "(first ())" "(first [])" "(empty? [])" "(take 3 (concat [[:foo]] (repeatedly (constantly :bar))))" "(take 2 (concat [[:foo]] (repeatedly (constantly :bar))))" "(take 2 (concat [[:foo]] (repeatedly :bar)))" "(take 2 (concat [[:foo]] (constantly :bar)))" "(take 2 (seq [[:foo] (constantly :bar)]))" "(take 10 (iterate inc 0))" "(let [foo (lazy-seq [:foo (range 1 100)])]
        (take 1 foo))" "(lazy-seq [:foo (range 1 100)])" "(lazy-seq [:foo :bar])" "(update-last (vec {:foo :bar :baz :qun}) (constantly :test))" "(vec {:foo :bar :baz :qun})" "(vec {:foo :bar})" "(count {:foo :bar})" "(count {:foo :bar :baz :qun})" "(update-last {:foo :bar} (constantly :baz))" "(update-last [0 1] (constantly 1000))" "(get [0 1] 1)" "(get [0 1] 2)" "(count [0 1])" "(1 2 3)" "(macroexpand #'clojure.core/+)" "(macroexpand '+)" "(macroexpand #'+)" "(eval #'+)" "(eval '+)" "'[+]" "'(+)" "#'+" "'#+" "'+" "(eval '[+ 1 2 3])" "(eval '(+ 1 2 3))" "(eval '(1 2 3))" "(concat '(range 10) '((+ 1 2)))" "(concat '(range 10) '(+ 1 2))" "(conj '(range 10) '(+ 1 2))" "(conj [] '(range 10))" "(doc defn-)" "(doc def-)" "(doc def)" "(doc defn-)" "(doc defn)" "(^ 1)" "^" "(get #{:foo :bar :baz} :qun)" "(get #{:foo :bar :baz} :foo)" "(doc new)" "#inst \"2016-09-19T20:40:02.733-00:00\"" "Math/PI" "(take 10 fib)" "(get-in my-warrior [:inventory :sword])" "(disj #{:shield} :shield)" "(remove :shield #{:shield})" "(remove #{:shield} :shield)" "(dissoc #{:shield} :shield)" "(+ 0.1 0.2)" "'~" "=~" "~~" "(def ~ 1)" "~" "clojure.lang.Vector" "clojure.lang.PersistentVector" "clojure.core.PersistentVector" "clojure.PersistentVector" "clojure.Vector" "java.lang.String" "clojure.core.Vector" "(doc ==)" "(== (+ 0.1 0.2) 0.3)" "(= (+ 0.1 0.2) 0.3)" ".1" "(take 10 bar)" "(take 2 bar)" "(take 2 foo)" "(take 2 foo)" "'(0 1)" "(concat '(1 2) '(1))" "(doc concat)" "(doc while)" "(doc when-let)" "(doc dotimes)" "(doc max)" "(doc slurp)" "(doc clojure.java.io/writer)" "(doc spit)" "(doc letfn)" "(doc let-fn)" "(doc while)" "(doc alts!)" "(doc alts!!)" "(doc not=)" "(not= :foo :bar)" "(= :foo :bar)" "(!= :foo :bar)" "(doc dissoc)" "(reduce (fn [count _] (inc count)) 0 [:foo :bar :baz])" "(reduce #(inc %1) 0 [:foo :bar :baz])" "(reduce #(inc %) 0 [:foo :bar :baz])" "(reduce inc 0 [:foo :bar :baz])" ":$3" ":3" "(doc <!)" "(doc chan)" "(doc <!!)" "(doc buffer)" "(doc a/dropping-buffer)" "(doc a/sliding-buffer)" "(doc sliding-buffer)" "(doc dropping-buffer)" "(doc chan)" ";foo" "\"foo\"" "(->> foo (take 10) (clojure.string/join \"\\n\") println)" "(->> foo (take 10) (clojure.string/join \" \") println)" "(->> foo (take 10) clojure.string/join println)" "(-> foo (take 10) clojure.string/join println)" "((partial apply str) '(\"foo\" \"bar\"))" "(-> foo (take 10) (partial apply str) println)" "(-> foo (take 10) .join println)" "(take 1 foo)" "(def foo (repeatedly (constantly \"hello world\")))" "(take 1 foo)" "(def foo (repeatedly #(\"hello world\")))" "foo" "clojure.core.async" "heists" "(-main)" "(ns-interns 'the-divine-cheese-code.visualization.svg)" "(ns-name 'the-divine-cheese-code.visualization.svg)" "(foo)" "refer" "(ns-name '*foo*)" "'*foo*" "(ns-interns 'user)" "(in-ns 'user)" "(clojure.core/+ 1 2)" "user/foo" "(in-ns '*foo*)" "user/foo" "(in-ns 'user)" "(+ 1 2)" "+" "map" "(in-ns '*foo*)" "(in-ns 'user)" "(ns-name *ns*)" "(in-ns '*foo*)" "*ns*" "(ns-name *foo*)" "(ns-name (create-ns '*foo*))" "(ns-name *ns*)" "(ns-name *foo*)" "((deref (get (ns-interns *ns*) 'foo)))" "(deref (get (ns-interns *ns*) 'foo))" "(deref #'user/foo)" "user/foo" "#'user/foo" "(ns-map *ns*)" "((ns-interns *ns*) 'foo)" "(eval (get (ns-interns *ns*) 'foo))" "(get (ns-interns *ns*) 'foo)" "(ns-interns *ns*)" "(get *ns* 'foo)" "foo" "(get *ns* foo)" "*ns*" "(eval '(map inc [1 2]))" "(ns-name *ns*)" "(xml-seq (clojure.data.xml/parse-str \"<foo bar='baz'>QUN</foo>\"))" "(xml-seq (parse-str \"<foo bar='baz'>QUN</foo>\"))" "(doc xml-seq (parse-str \"<foo bar='baz'>QUN</foo>\"))" "(doc xml-seq)" "not=" "!=" "(doc update)" "(prompt-rows)" "(rest \"foo\")" "(first \"foo\")" "(not-empty {:foo 1})" "(not-empty {})" "(not-empty nil)" "not-empty" "foo" "my-board" "new-board" "my-board" "(+ \"1\" 2)" "doc" "(doc int)" "(conj [] '(:foo))" "(conj [] :foo)")