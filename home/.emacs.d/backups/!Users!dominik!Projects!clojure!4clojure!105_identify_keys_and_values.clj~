;; straightforward, scheme-style solution
(defn identify
  [coll]
  (loop [result {}
         last-key nil
         remaining coll]
    (if (empty? remaining)
      result
      (if (= (type (first remaining)) clojure.lang.Keyword)
        (recur (assoc result (first remaining) [])
               (first remaining)
               (rest remaining))
        (recur (update result last-key conj (first remaining))
               last-key
               (rest remaining))))))


;; reduce-based solution
(defn identify-fn
  [acc el]
  (if (= (type el) clojure.lang.Keyword)
    (conj acc [el []])
    (update-in acc [(dec (count acc)) 1] conj el)))
(defn identify
  [coll]
  (reduce merge {} (reduce identify-fn [] coll)))


;; two reduce-based solutions, versions for 4clojure
(fn [coll]
  (reduce merge
          {}
          (reduce #(if (= (type %2) clojure.lang.Keyword)
                     (conj %1 [%2 []])
                     (update-in %1 [(dec (count %1)) 1] conj %2))
                  []
                  coll)))

(comp (partial reduce merge {})
      (partial reduce
               #(if (= (type %2) clojure.lang.Keyword)
                  (conj %1 [%2 []])
                  (update-in %1 [(dec (count %1)) 1] conj %2))
               []))


;; test
(identify [])
(identify [:a 1, :b 2])
(identify [:a 1 2 3 :b :c 4])

