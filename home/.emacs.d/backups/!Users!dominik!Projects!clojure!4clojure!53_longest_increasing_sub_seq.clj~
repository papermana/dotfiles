(defn return-bigger
  [f & args]
  (reduce #(if (> (f %1) (f %2)) %1 %2) args))

(defn trim-beyond-increasing-nums
  [coll]
  (if (empty? coll)
    coll
    (let [size (count coll)]
      (loop [a 0, b 1]
        (cond
          (= b size) coll
          (> (coll b) (coll a)) (recur (inc a) (inc b))
          :else (subvec coll 0 b))))))

(defn longest-increasing-subseq
  [coll]
  (->> (range (count coll))
       (map (partial subvec coll))
       (map trim-beyond-increasing-nums)
       (filter #(> (count %) 1))
       (reduce (partial return-bigger count) [])))

(longest-increasing-subseq [1 0 1 2 3 0 4 5])
(longest-increasing-subseq [7 6 5 4])
