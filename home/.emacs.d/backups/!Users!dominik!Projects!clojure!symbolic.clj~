
(def actions {:+ {:arity 2
                  :function +
                  :complement -}
              :* {:arity 2
                  :function *
                  :complement /}})

(let [last-id (atom -1)]
  (defn get-id
    []
    (swap! last-id inc)
    @last-id))

(defn analyze-exp
  [caller exp]
  (if-not (seq? exp)
    (let [var (atom {:type :variable
                     :name (keyword exp)
                     :connections [caller]})]
      (swap! caller update :connections #(conj % var))
      var)
    (let [fst (first exp)
          rst (rest exp)
          fst-var (atom {:type :action
                         :f (keyword fst)
                         :connections [caller]})
          rst-var (map (partial analyze-exp fst-var) rst)]
      (swap! caller update :connections #(conj % fst-var))
      fst-var)))

(analyze-exp (atom {}) 'c)

(def example-state
  {:vars {:c 1, :f 6}
   :objs {1 {:type :variable
             :name :c
             :connections [2]
             :value nil}
          2 {:type :action
             :f :+
             :connections [1 3 4]
             :value nil}
          3 {:type :constant
             :value 9/5}}})

(defn variable? [x] (symbol? x))

(defn make-variable-obj
  [var-name caller-id]
  {:type :variable
   :name var-name
   :connections [caller-id]
   :value nil})

(defn analyze-variable
  [state caller-id var id]
  (-> state
      (assoc-in [:vars (keyword var)] id)
      (assoc-in [:objs id] (make-variable-obj (keyword var)
                                              caller-id))))

(defn constant? [x] (number? x))

(defn make-constant-obj
  [value caller-id]
  {:type :constant
   :connections [caller-id]
   :value value})

(defn analyze-constant
  [state caller-id value id]
  (assoc-in state [:objs id] (make-constant-obj value caller-id)))

(defn make-action-obj
  [f caller-id rest-ids]
  {:type :action
   :f f
   :connections (apply conj [caller-id] rest-ids)
   :value nil})

(defn analyze-action
  [state caller-id action id rest]
  (let [rest-id (map (fn [x] [(get-id) x]) rest)
        state-with-action (assoc-in state
                                    [:objs id]
                                    (make-action-obj (keyword action)
                                                     caller-id
                                                     (map first rest-id)))]
    (reduce (fn [state [el-id el]]
              (let [f (cond
                        (variable? el) analyze-variable
                        (constant? el) analyze-constant
                        :else analyze-exp)]
                (f state id el el-id)))
            state-with-action
            rest-id)))

(defn analyze-exp
  [state caller-id exp id]
  (analyze-action state
                  caller-id
                  (first exp)
                  id
                  (rest exp)))

(def state (analyze-action {} -1 '+ 0 '(1 c)))

(defn user-set-var-value
  [state var-name value]
  (let [id (get-in state [:vars var-name])
        new-state (assoc-in state [:objs id :value] value)
        connections (get-in state [:objs id :connections])]
    (reduce (partial set-value id) new-state connections)))

(defn set-value
  [caller-id state obj-id]
  (let [f (case (get-in state [:objs obj-id :type])
            :variable set-var-value
            :constant set-const-value
            set-action-value)]
    (f state obj-id caller-id)))

(defn set-var-value
  [state id caller-id]
  (let [connections (->> (get-in state [:objs id :connections])
                         (filter (partial not= caller-id)))
        new-state (assoc-in state
                            [:objs id :value]
                            (get-in state [:objs caller-id :value]))]
    (reduce (partial set-value id) new-state connections)))

(defn set-const-value
  [state id caller-id]
  (let [connections (->> (get-in state [:objs id :connections])
                         (filter (partial not= caller-id)))]
    (reduce (partial set-value id) state connections)))

(defn set-action-value
  [state id caller-id]
  (let [connections (->> (get-in state [:objs id :connections])
                         (filter (partial not= caller-id)))
        constants (filter #(= (get-in state [:objs % :type]) :constant)
                          connections)
        caller-value (get-in state [:objs caller-id :value])
        const-values (map #(get-in state [:objs % :value]) constants)
        non-constants (filter #(not= (get-in state [:objs % :type])
                                     :constant)
                              connections)
        f (actions (get-in state [:objs id :f]))]
    (if (= (inc (count constants)) (:arity f))
      (let [new-value (apply (:function f)
                             (cons caller-value const-values))
            new-state (assoc-in state [:objs id :value] new-value)]
        (reduce (partial set-value id) new-state non-constants))
      state)))

(user-set-var-value state :c 20)

(let [state (analyze-exp {} -1 '(+ 32 (* 9/5 c)) 0)]
  (user-set-var-value state :c 20))
