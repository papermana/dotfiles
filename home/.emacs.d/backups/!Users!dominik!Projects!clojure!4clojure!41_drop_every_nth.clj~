(defn drop-a
  [coll n]
  (reverse
   (loop [result ()
          i 1
          remaining coll]
     (cond
       (empty? remaining) result
       (= (mod i n) 0) (recur result
                              (inc i)
                              (rest remaining))
       :else (recur (conj result (first remaining))
                    (inc i)
                    (rest remaining))))))

(drop-a [1 2 3 4 5 6 7 8] 3)


(defn drop-b
  [coll n]
  (keep-indexed (fn [index val]
                  (when (not= (mod (inc index) n) 0) val))
                coll))

(drop-b [1 2 3 4 5 6 7 8] 3)
