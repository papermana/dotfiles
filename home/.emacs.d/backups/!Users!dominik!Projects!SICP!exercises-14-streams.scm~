(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x) (newline) (display x))

; (define (cons-stream a b) (cons a (delay b)))
; cons-stream cannot be a procedure because we do not want to eagerly evaluate b, as we normally would an argument to a function

(define (stream-car s) (car s))

(define (stream-cdr s) (force (cdr s)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream low
                   (stream-enumerate-interval (+ low 1)
                                              high))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))


;; 3.50

(define (stream-map proc . argstreams)
  (if (stream-null? (car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))


;; 3.51

; The interpreter is going to print out numbers from 0 to 5, and then from 0 to 7 again.
; Correction: It is going to print out 0 as a result of defining x, then numbers from 1 to 5 as a result of the first call to stream-ref, then 6 and 7 as a reult of the second call.

(define (show x) (display-line x) x)

(define x (stream-map show (stream 0 1 2 3 4 5 6 7 8 9)))

(stream-ref x 5)
(stream-ref x 7)


;; 3.52

(define sum 0)
; sum is 0

(define (accum x) (set! sum (+ x sum)) sum)
; sum is still 0

(define seq
  (stream-map accum
              (stream-enumerate-interval 1 20)))
; sum is now 1 because we invoke accum on the first element of the stream (one that wasn't a promise)

(define y (stream-filter even? seq))
; sum is now 3 because stream-filter will process the stream until it gets at least one even element (2)

(define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                         seq))
; sum is now 15

(stream-ref y 7)
; sum is now 28

(display-stream z)
; sum is now the sum of all numbers between 7 and 20

; If we didn't implement the memo-proc optimization, then every procedure would start from the very beginning rather than from where a previous one left. In essence, rather than adding all the numbers from 1 to 20, we would add 1, 1 and 2, 1 to 5, 1 to 7, and 1 to 20 all together. 
; Correction: all of the above is apparently wrong...


;;

(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1))))

(define integers (integers-starting-from 1))

(define (divisible? x y) (= (remainder x y) 0))

(define no-sevens
  (stream-filter (lambda (x) (not (divisible? x 7)))
                 integers))

(stream-ref no-sevens 100)

(define (fibgen a b) (cons-stream a (fibgen b (+ a b))))

(define fibs (fibgen 0 1))

(stream-ref fibs 100)

(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter
           (lambda (x) (not (divisible? x (stream-car stream))))
           (stream-cdr stream)))))

(define primes (sieve (integers-starting-from 2)))

(define ones (cons-stream 1 ones))

(define (add-streams s1 s2) (stream-map + s1 s2))

(define integers (cons-stream 1 (add-streams ones integers)))

(define fibs
  (cons-stream 0
               (cons-stream 1
                            (add-streams (stream-cdr fibs) fibs))))

(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor))
              stream))

(define double (cons-stream 1 (scale-stream double 2)))


(define primes
  (cons-stream 2
               (stream-filter prime? (integers-starting-from 3))))

(define (prime? n)
  (define (iter ps)
    (cond ((> (square (stream-car ps)) n) true)
          ((divisible? n (stream-car ps)) false)
          (else (iter (stream-cdr ps)))))
  (iter primes))


;; 3.53

(define s (cons-stream 1 (add-streams s s)));

; index 0 -> 1
; index 1 -> 2
; index 2 -> 4
; index 3 -> 8
; ...
; index n -> 2^n

; This stream is effectively the same as double defined earlier.


;; 3.54

(define (mul-streams s1 s2) (stream-map * s1 s2))

(define factorials
  (cons-stream 1
               (mul-streams integers factorials)))


;; 3.55

(define (partial-sums s)
  (define foo
    (cons-stream (stream-car s)
                 (add-streams foo (stream-cdr s))))
  foo)

(stream-ref (partial-sums integers) 4)


;; 3.56

(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream
                   s1car
                   (merge (stream-cdr s1) s2)))
                 ((> s1car s2car)
                  (cons-stream
                   s2car
                   (merge s1 (stream-cdr s2))))
                 (else (cons-stream
                        s1car
                        (merge (stream-cdr s1)
                               (stream-cdr s2)))))))))

(define S
  (cons-stream 1 (merge (scale-stream integers 2)
                        (merge (scale-stream integers 3)
                               (scale-stream integers 5)))))


;; 3.57

; copied from before
(define fibs
  (cons-stream 0
               (cons-stream 1
                            (add-streams (stream-cdr fibs) fibs))))

; Let's say we want to get the 6th Fibonacci number. In order to do that, we have to pass through all the indices of the stream until the fifth one.
; Index 0: simply evaluates to 0.
; Index 1: simply evaluates to 1.
; Index 2: add the cars of two streams, one being fibs itself and the other being its cdr. Both of those elements still simply evaluate to numbers.
; Index 3: now the car of the stream-cdr is the same as index 2. But since streams are lazily evaluated, the value that got returned just before isn't actually saved anywhere. Because of that, the stream-map operation is going to have to be repeated to get the value again.
; Index 4: now cars of both streams that we're adding refer to return values from map operations. What's more, while one of these operations uses just plain numbers as inputs, the other one has to calculate index 3, which itself has to calculate index 2.
; Index 5: now cars of both streams we're adding have to calculate an additional map operation, with one of them being index 3 and having to calculat a map operation for index 2; the other one having to calculate map operations for indices 4, 3 and 2.


;; 3.58

(define (expand num den radix)
  (cons-stream (quotient (* num radix) den)
               (expand (remainder (* num radix) den)
                       den
                       radix)))

(expand 1 7 10)
(cons-stream 1 (expand 3 7 10))
(cons-stream 1
             (cons-stream 4 (expand 2 7 10)))
(cons-stream 1
             (const-stream 4
                           (const-stream 2
                                         (expand 6 7 10))))
(const-stream 1
              (const-stream 4
                            (const-stream 2
                                          (const-stream 8
                                                        (expand 4 7 10)))))

; (expand 1 7 10) creates an infinite stream consisting of a looped sequence 1428428428...

(stream-ref (expand 3 8 10) 4)
; produces a looped sequence 375000...


;; 3.59

; a)
(define (integrate-series series)
  (define (iter series i)
    (if (empty-stream? series)
        the-empty-stream
        (cons-stream (* (stream-car series) (/ 1 i))
                     (iter (stream-cdr series) (+ i 1)))))
  (iter series 1))

(define (integrate-series series)
  (stream-map / series integers))

; b)
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))

(define cosine-series (cons-stream 1 (integrate-series sine-series)))

(define sine-series (cons-stream 0 (integrate-series cosine-series)))


;; 3.60

(define (mul-series s1 s2))
; no idea!

(stream-ref (add-streams (mul-series cosine-series cosine-series)
                         (mul-series sine-series sine-series))
            1)


;; 3.61

; skipping it


;; 3.62

; skipping this one as well


;;

(define (pi-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (pi-summands (+ n 2)))))
(define pi-stream
  (scale-stream (partial-sums (pi-summands 1))
                4))

(define (euler-transform s)
  (let ((s0 (stream-ref s 0))
        (s1 (stream-ref s 1))
        (s2 (stream-ref s 2)))
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))

(define (make-tableau transform s)
  (cons-stream s (make-tableau transform (transform s))))

(define (accelerated-sequence transform s)
  (stream-map stream-car (make-tableau transform s)))


;; 3.63

; Let's trace the execution of Louis's program:
(sqrt-stream 2)
(cons-stream 1.0 (stream-map (lambda (guess) (sqrt-improve guess 2))
                             (sqrt-stream 2)))

; Now, to get the first element we simply get 1.0, and to get the second element we map sqrt-improve onto the first element of a new sqrt-stream of 2, which returns 1.0.
; To get the third element, we have to map sqrt-improve onto the second element of a new sqrt-stream of 2, which itself requires we create another sqrt-stream of 2.
; In other words, to get the nth element of the Louis's version sqrt-stream, we need to create n-1 new sqrt-streams, in addition to the number required to get all the previous elements. Thus, the procedure becomes O(n^2) (?).
; We can actually calculate how many new streams we would have to create by using partial-sums and getting an element at the index n-2 (e.g. index 2 for trying to get the fourth element of sqrt-stream).
(stream-ref (partial-sums integers) 2)

; However, I don't think this version would work any differently from the original one if we hadn't used memo-proc in our implementation of delay. As streams are lazy, we would still have to recalculate all the previous elements. memo-proc helps us here because we go over the same promises over and over.


;; 3.64

(define (stream-limit s tolerance)
  (let ((s0 (stream-car s))
        (s1 (stream-car (stream-cdr s))))
    (if (< (abs (- s1 s0)) tolerance)
        s1
        (stream-limit (stream-cdr s) tolerance))))


;; 3.65

(define (ln2-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (ln2-summands (+ n 1)))))

(define ln2-stream
  (partial-sums (ln2-summands 1)))

(define ln2-accelerated (accelerated-sequence euler-transform ln2-stream))
(stream-ref ln2-accelerated 0) ; 1
(stream-ref ln2-accelerated 1) ; .7
(stream-ref ln2-accelerated 2) ; .6932773109243697


;;

(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))


;; 3.66

(define int-pairs (pairs integers integers))

; The first 10 elements of int-pairs is:
; (1 1) (1 2) (2 2) (1 3) (2 3) (1 4) (3 3) (1 5) (2 4) (1 6)

; It seems like (because of interleave) every other pair has the car of 1, in addition to the first pair being (1 1). Therefore, to get the pair (1 n), we need to calculate (* 2 (- n 1)) pairs:
(* 2 (- 3 1)) ; 4
(* 2 (- 4 1)) ; 6
(* 2 (- 100 1)) ; 198

; The first (2 x) pair appears as the 3rd element; the first (3 x) pair appears as the 7th element; the first (4 x) pair will appear as the 15th element. Because of interleaved interleaves, each subsequent "s-pair" will appear half as often (i.e. s=1 will appear as every other pair, s=2 as every other from among the rest, then s=3 as every other from among the rest of that rest, etc.).
; In other words, pairs whose car is 1 will make up 1/2 of the stream; pairs whose car is 2 will make up 1/4 of the stream; and so on. We can therefore calculate how much of our stream consists of pairs whose car is n by performing the calculation (/ 1 (expt 2 n)):
(/ 1 (expt 2 2)) ; 1/4
(/ 1 (expt 2 3)) ; 1/8
(/ 1 (expt 2 99)) ; 1/633825300114114700748351602688
(/ 1 (expt 2 100)) ; 1/1267650600228229401496703205376

; Therefore, we can calculate which element in the stream is the pair (n m) using the calculation (* (- m (- n 1)) (- (expt 2 n) 1)):
(* (- 2 (- 2 1)) (- (expt 2 2) 1)) ; 3
(* (- 4 (- 2 1)) (- (expt 2 2) 1)) ; 9
(* (- 3 (- 3 1)) (- (expt 2 3) 1)) ; 7
(* (- 100 (- 99 1)) (- (expt 2 99) 1)) ; 1267650600228229401496703205374
(* (- 100 (- 100 1)) (- (expt 2 100) 1)) ; 1267650600228229401496703205375


;; 3.67

(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) t))))

(define (display-n-from-stream s n)
  (if (or (empty-stream? s) (= n 0))
      'done
      (begin (display (stream-car s))
             (display " ")
             (display-n-from-stream (stream-cdr s) (- n 1)))))

(display-n-from-stream (pairs integers integers) 20)


;; 3.68

; Louis's code:
(define (pairs s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))

(display-n-from-stream (pairs integers integers) 0)

; This will not work because interleave is a regular function that will evaluate its arguments first, and one of the arguments is a recursive call to pairs. Thus, the program will create an infinite (non-lazy) loop.


;; 3.69

(define (triples s t u)
  (cons-stream
   (list (stream-car s) (stream-car t) (stream-car u))
   (interleave
    (stream-map (lambda (x)
                  (cons (stream-car s) x))
                (pairs (stream-cdr t) (stream-cdr u)))
    (triples (stream-cdr s) (stream-cdr t) (stream-cdr u)))))

(display-n-from-stream (triples integers integers integers) 20)

(define pyth
  (stream-filter (lambda (triple)
                   (let ((i (list-ref triple 0))
                         (j (list-ref triple 1))
                         (k (list-ref triple 2)))
                     (= (+ (square i) (square j))
                        (square k))))
                 (triples integers integers integers)))

(display-n-from-stream pyth 20)


;; 3.70

(define (merge-weighted weight s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((weighted-s1 (weight (stream-car s1)))
               (weighted-s2 (weight (stream-car s2))))
           (cond ((< weighted-s1 weighted-s2)
                  (cons-stream (stream-car s1)
                               (merge-weighted weight (stream-cdr s1) s2)))
                 ((> weighted-s1 weighted-s2)
                  (cons-stream (stream-car s2)
                               (merge-weighted weight s1 (stream-cdr s2))))
                 (else
                  (cons-stream
                   (stream-car s1)
                   (merge-weighted weight (stream-cdr s1) s2))))))))

(define (weighted-pairs weight s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (merge-weighted
    weight
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (weighted-pairs weight (stream-cdr s) (stream-cdr t)))))

(define merged-stream-a
  (weighted-pairs (lambda (pair) (+ (car pair)
                                    (car (cdr pair))))
                  integers
                  integers))

(display-n-from-stream merged-stream-a 20)

(define merged-stream-b
  (stream-filter (lambda (pair)
                   (let ((i (car pair))
                         (j (car (cdr pair))))
                     (and (not (divisible? i 2))
                          (not (divisible? i 3))
                          (not (divisible? i 5))
                          (not (divisible? j 2))
                          (not (divisible? j 3))
                          (not (divisible? j 5)))))
                 (weighted-pairs (lambda (pair)
                                   (let ((i (car pair))
                                         (j (car (cdr pair))))
                                     (+ (* 2 i)
                                        (* 3 j)
                                        (* 5 (* i j)))))
                                 integers
                                 integers)))

(display-n-from-stream merged-stream-b 20)


;; 3.71

;; This is fragile as it will duplicate results in the final stream if there are more than two pairs that give the same Ramanujan number.
(define (find-doubles s)
  (define (iter s previous-value)
    (if (eq? (stream-car s) previous-value)
        (cons-stream
         (stream-car s)
         (iter (stream-cdr s) (stream-car s)))
        (iter (stream-cdr s) (stream-car s))))
  (iter (stream-cdr s) (stream-car s)))

(define ramanujan-nums
  (let ((weight (lambda (pair)
                  (let ((i (car pair))
                        (j (car (cdr pair))))
                    (+ (* i i i)
                       (* j j j))))))
    (find-doubles
     (stream-map weight
                 (weighted-pairs weight
                                 integers
                                 integers)))))

(display-n-from-stream ramanujan-nums 20)


;; 3.72

;; Note that we could generalize it into a higher-order procedure find-*, which would accept the number of repeated numbers we are looking for and return a new function containing a line ((= (length repeated-nums) n)).
(define (find-triples s)
  (define (get-sum value) (car value))
  (define (get-pair value) (cadr value))
  (define (iter s previous-value repeated-nums)
    (let ((car-s (stream-car s)))
      (cond ((eq? (get-sum car-s) previous-value)
             (iter (stream-cdr s)
                   previous-value
                   (cons (get-pair (stream-car s)) repeated-nums)))
            ((= (length repeated-nums) 3)
             (cons-stream repeated-nums
                          (iter (stream-cdr s)
                                (get-sum car-s)
                                (list (get-pair car-s)))))
            (else (iter (stream-cdr s)
                        (get-sum car-s)
                        (list (get-pair car-s)))))))
  (iter (stream-cdr s) (stream-car s) '()))

(define square-sums
  (let ((weight (lambda (pair)
                  (let ((i (car pair))
                        (j (car (cdr pair))))
                    (+ (square i) (square j))))))
    (stream-for-each (lambda (l)
                       (display (list (weight (car l)) l))
                       (newline))
                     (find-triples
                      (stream-map (lambda (pair) (list (weight pair) pair))
                                  (weighted-pairs weight
                                                  integers
                                                  integers))))))

